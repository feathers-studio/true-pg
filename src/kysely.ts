import type { CanonicalType, SchemaType, TableColumn } from "pg-extract";
import type { createGenerator, Generator } from "./types";

export const Kysely: createGenerator = (opts = { enumTo: "enum" }): Generator => {
	// const insertUpdate = mode === "insert" || mode === "update";

	const column = (
		/** @out Append used types to this array */
		types: CanonicalType[],
		/** Information about the column */
		col: TableColumn,
	) => {
		let base = col.type.canonical_name;
		if (col.type.dimensions > 0) base += "[]".repeat(col.type.dimensions);
		if (col.isNullable) base += " | null";

		let qualified = base;
		if (col.generated === "ALWAYS") qualified = `K.GeneratedAlways<${qualified}>`;
		else if (col.generated === "BY DEFAULT") qualified = `K.Generated<${qualified}>`;
		else if (col.defaultValue) qualified = `K.Generated<${qualified}>`;

		const generated = col.generated === "ALWAYS" || col.generated === "BY DEFAULT";

		const comments = [];
		if (col.comment) comments.push(col.comment);
		if (generated) comments.push("@generated This column is generated by the database.");
		if (col.defaultValue) comments.push(`@defaultValue {${col.defaultValue}}`);
		const comment = comments.length > 0 ? `/**\n\t * ${comments.join("\n\t * ")}\n\t */\n\t` : "";

		let out = comment;

		out += col.name;
		// TODO: update imports for non-primitive types
		out += `: ${qualified}`;
		types.push(col.type);
		if (col.type.dimensions > 0) out += "[]".repeat(col.type.dimensions);

		return `\t${out};\n`;
	};

	const composite_attribute = (types: CanonicalType[], attr: CanonicalType.CompositeAttribute) => {
		let out = attr.name;

		if (attr.isNullable) out += "?";
		out += `: ${attr.type.canonical_name}`;
		types.push(attr.type);
		if (attr.type.dimensions > 0) out += "[]".repeat(attr.type.dimensions);
		if (attr.isNullable) out += " | null";

		return out;
	};

	return {
		/**
		 * Split on _ and space and capitalise each letter
		 * @defaultValue PascalCases type names
		 */
		getTypeName(type) {
			return type.name //
				.replace(" ", "_")
				.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase())
				.replace(/^([a-z])/, (_, letter) => letter.toUpperCase());
		},

		table(types, table) {
			let out = "";

			let ifaceName = table.name;

			if (table.comment) out += `/** ${table.comment} */\n`;
			out += `export interface ${ifaceName} {\n`;
			for (const col of table.columns) out += column(types, col);
			out += "}\n";

			return out;
		},

		enum(types, en) {
			let out = "";

			if (en.comment) out += `/** ${en.comment} */\n`;

			if (opts.enumTo === "union") {
				out += `export type ${en.name} = ${en.values.map(v => `"${v}"`).join(" | ")};\n`;
			} else {
				out += `export enum ${en.name} {\n`;
				for (const v of en.values) out += `\t"${v}" = "${v}",\n`;
				out += "}\n";
			}

			return out;
		},

		composite(types, type) {
			let out = "";

			if (type.comment) out += `/** ${type.comment} */\n`;
			out += `export interface ${type.name} {\n`;

			const props = type.canonical.attributes.map(c => composite_attribute(types, c)).map(t => `\t${t};`);
			out += props.join("\n");
			out += "\n}\n";

			return out;
		},

		function(types, type) {
			let out = "";

			out += "/**\n";
			if (type.comment) out += ` * ${type.comment}\n`;
			out += ` * @volatility ${type.volatility}\n`;
			out += ` * @parallelSafety ${type.parallelSafety}\n`;
			out += ` * @isStrict ${type.isStrict}\n`;
			out += " */\n";
			out += "export interface ";
			out += type.name;
			out += " {\n\t";

			// Get the input parameters (those that appear in function signature)
			const inputParams = type.parameters.filter(
				p => p.mode === "IN" || p.mode === "INOUT" || p.mode === "VARIADIC",
			);

			if (inputParams.length === 0) {
				out += "(): ";
			} else if (inputParams.length === 1) {
				out += "(";
				out += inputParams[0]!.name;
				out += ": ";
				out += inputParams[0]!.type.canonical_name;
				types.push(inputParams[0]!.type);
				if (inputParams[0]!.type.dimensions > 0) out += "[]".repeat(inputParams[0]!.type.dimensions);
				out += "): ";
			} else if (inputParams.length > 0) {
				out += "(\n";

				for (const param of inputParams) {
					// Handle variadic parameters differently if needed
					const isVariadic = param.mode === "VARIADIC";
					const paramName = isVariadic ? `...${param.name}` : param.name;

					out += `\t\t${paramName}`;
					if (param.hasDefault && !isVariadic) out += "?";
					// TODO: update imports for non-primitive types based on typeInfo.kind
					out += `: ${param.type.canonical_name}`;
					types.push(param.type);
					if (param.type.dimensions > 0) out += "[]".repeat(param.type.dimensions);
					if (!isVariadic) out += ",";
					out += "\n";
				}

				out += "\t): ";
			}

			if (type.returnType.kind === "table") {
				out += "{\n";
				for (const col of type.returnType.columns) {
					out += `\t\t${col.name}: `;
					out += col.type.canonical_name;
					types.push(col.type);
					if (col.type.dimensions > 0) out += "[]".repeat(col.type.dimensions);
					out += `;\n`;
				}
				out += "\t}";
			} else {
				out += type.returnType.type.canonical_name;
				types.push(type.returnType.type);
				if (type.returnType.type.dimensions > 0) out += "[]".repeat(type.returnType.type.dimensions);
			}

			// Add array brackets based on dimensions
			if (type.returnType.kind === "regular" && type.returnType.type.dimensions > 0) {
				out += "[]".repeat(type.returnType.type.dimensions);
			}

			// Add additional array brackets if it returns a set
			if (type.returnType.isSet) {
				out += "[]";
			}

			out += ";\n}\n";

			return out;
		},

		imports(types) {
			if (types.length === 0) return "";
			return `import type { pg_catalog, public } from "../../index.ts";\n`;
		},

		schemaIndex(types) {
			// at the moment we only really support these types
			// functions may have conflicting names with tables, so we don't include them
			const TYPES: SchemaType["kind"][] = ["table", "enum", "composite"];
			return (
				types
					.filter(t => TYPES.includes(t.kind))
					.map(t => `export * from "./${t.kind}s/${t.name}.ts";`)
					.join("\n") + "\n"
			);
		},

		fullIndex(schemas: string[]) {
			return schemas.map(s => `export * as ${s} from "./${s}/index.ts";`).join("\n") + "\n";
		},
	};
};
